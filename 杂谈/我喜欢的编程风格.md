# 我喜欢的编程风格

## 声明

- 本文是一篇杂谈, 因而起严谨性不会得到保证, 引用的相关资料的原始链接也可能不会给出.
- 写这篇文的原因: 某日和网友偶然讨论起编程风格的问题, 想到之前写了一篇相关的文, 它很不完善也很不可读.  
  于是我决定重新写一篇关于编程风格的杂谈.
- 正如题目所言,这篇文的内容,仅仅是我自己不成熟的实践经验和未经检验的思考.

## 背景

- 网友:"How to implement `Dijkstra's algorithm for single source shortest path` in a non-imperative or functional style?"  
  我们必须指出一下事实  
  1. 和`imperative(命令式)`风格的对立面,应该称为`declarative(声明式)`.
  2. `functional programming`是和`procedural programming`以及`objective-oriented programming`等范式并列的.
  3. 计算模型/编程语言/编程范式 三者之间没有明确的关联. 但是由于Turing machine和lambda calculus的计算能力是相同的,`procedural programming`的程序容易和Turing machine对应而`functional programming`的程序容易和lambda calculus对应. 所以并没有"某个算法,仅仅可以用某种风格,某个范式的语言实现".
  我们应该写点东西,阐述不同的风格的特点,不同风格的着眼点,不同风格的例子,不同风格的适用场景.
- "一个神奇的C/Cpp,golang面试题/学校课程考试题. 有很强的歧义性,很不符合直觉,并且程序的风格非常坏, 所谓ill-shaped"  
  应当记录一些坏例子和好例子,用以提醒自己和它人. 我们要尽力避免所适用的编程语言的缺陷,写出高质量的代码.
- "zen of python", `python -c "import this"`
- 进行编程时. 有哪些特性/哪些风格,是我喜欢的,是我常常使用的?
- 进行编程时. 有哪些值得注意的指标, 什么是"高质量的实现",什么是"优秀的设计"?

## 我的想法

- `declarative`和`imperative`没有明确的高下之分, 表达能力的强弱,和编程风格的相关度没有人们的幻想中那么高.
- explicit, consistent, composable, extensible 是实现和设计的基本原则.  
  显式的,明确的,无歧义的; 一致的,不自相矛盾的.   这保证了符合直觉,或者至少符合某套体系的演算规则,这样的程序是reasonable的.
  易于组合,易于扩展;  这样的程序,是能够形成一个可用可靠可发展的整体的.


- 我会允许内部使用了可变性,而外部观测表现为纯函数的代码. 只要它不扩散,不影响组合性.
- 我喜欢不可变的数据结构, 不可变性可以帮助规避很多难以察觉,难以探测的问题.

## 多种编程风格,编程范式间的对比




## 很多例子


### 一些关于可变性的坏例子

```go
package main
import "fmt"
func twoClosure(base int) (func(int)(int),func(int)int){
    fa := func(v int) int{
        base+=v
        return base
    }
    fs := func(v int) int{
        base-=v
        return base
    }
    return fa,fs
}
func main(){
    fa,fs := twoClosure(10)
    fmt.Println(fa(1),fs(3))
    //output:11,8
}
```

```cpp
std::vector<int> vec;
void append(x){ vec.push_back(x); }
int func(int i){
  while(i>0) append(i--);
  return int(vec.size());
}
int main(){
  int n=read();
  for(int i=0;i<n;i++) append(read());
  for(int i=0;i<n;i++) vec[i]=func(i);
  return 0
}
```

### 一些好例子




